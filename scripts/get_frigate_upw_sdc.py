from report import Report
import click
import re
import textwrap
import time


@click.command()
@click.option(
    "--mprj-reports-dir",
    required=True,
    type=click.Path(exists=True, file_okay=False),
    help="path to the directory that includes the mprj timing reports from PrimeTime",
)
@click.option(
    "-o",
    "--output-sdc",
    required=True,
    type=str,
    help="output sdc",
)
def main(mprj_reports_dir, output_sdc):
    # a variation value of +-0.4 is applied on the extracted constraints
    # the value is determined after extracting constraints from
    # multiple implementations to provide tightened PnR constraints
    # the value is removed from the signoff sdc
    output_sdc_signoff = output_sdc[:-4] + "_signoff" + ".sdc"
    global var
    var = 0.4
    timestr = time.strftime("%Y/%m/%d")

    in_min_rpt = f"{mprj_reports_dir}/in-min.rpt"
    in_max_rpt = f"{mprj_reports_dir}/in-max.rpt"
    out_min_rpt = f"{mprj_reports_dir}/out-min.rpt"
    out_max_rpt = f"{mprj_reports_dir}/out-max.rpt"
    clk_min_rpt = f"{mprj_reports_dir}/clk-min.rpt"
    clk_max_rpt = f"{mprj_reports_dir}/clk-max.rpt"

    in_delays, in_async_cons, signoff_in_delays, signoff_in_async = get_input_delays_cons(in_min_rpt, in_max_rpt)
    input_trans = get_input_transitions_cons(in_min_rpt, in_max_rpt)
    out_delays, out_async_cons, signoff_out_delays, signoff_out_async = get_output_delays_cons(out_min_rpt, out_max_rpt)
    output_loads = get_loads_cons(out_max_rpt)
    clk_cons = get_clock_cons(clk_min_rpt, clk_max_rpt)
    predefined = predefined_cons(timestr)
    predefined_signoff = predefined_signoff_cons(timestr)
    with open(output_sdc, "w") as sdc:
        for cons in predefined:
            sdc.write(cons)
        sdc.write("\n#------------------------------------------#\n")
        sdc.write("# Retrieved Constraints\n")
        sdc.write("#------------------------------------------#\n")
        for cons in clk_cons:
            sdc.write(cons)
        sdc.write("\n# Input delays\n")
        for cons in in_delays:
            sdc.write(cons)
        sdc.write("if { $::env(IO_SYNC) } {\n")
        sdc.write("\tset in_ext_delay 4\n")
        sdc.write("\tputs \"\\[INFO\\]: Setting input ports external delay to: $in_ext_delay\"\n")
        for cons in in_async_cons:
            sdc.write(f"\t{cons}")
        sdc.write("}\n")
        sdc.write("\n# Input Transition\n")
        for cons in input_trans:
            sdc.write(cons)
        sdc.write("\n# Output delays\n")
        for cons in out_delays:
            sdc.write(cons)
        sdc.write("if { $::env(IO_SYNC) } {\n")
        sdc.write("\tset out_ext_delay 4\n")
        sdc.write("\tputs \"\\[INFO\\]: Setting output ports external delay to: $out_ext_delay\"\n")
        for cons in out_async_cons:
            sdc.write(f"\t{cons}")
        sdc.write("}\n")
        sdc.write("\n# Output loads\n")
        for cons in output_loads:
            sdc.write(cons)

    with open(output_sdc_signoff, "w") as sdc:
        for cons in predefined_signoff:
            sdc.write(cons)
        sdc.write("\n#------------------------------------------#\n")
        sdc.write("# Retrieved Constraints\n")
        sdc.write("#------------------------------------------#\n")
        for cons in clk_cons:
            sdc.write(cons)
        sdc.write("\n# Input delays\n")
        for cons in signoff_in_delays:
            sdc.write(cons)
        sdc.write("if { $::env(IO_SYNC) } {\n")
        sdc.write("\tset in_ext_delay 4\n")
        sdc.write("\tputs \"\\[INFO\\]: Setting input ports external delay to: $in_ext_delay\"\n")
        for cons in signoff_in_async:
            sdc.write(f"\t{cons}")
        sdc.write("}\n")
        sdc.write("\n# Input Transition\n")
        for cons in input_trans:
            sdc.write(cons)
        sdc.write("\n# Output delays\n")
        for cons in signoff_out_delays:
            sdc.write(cons)
        sdc.write("if { $::env(IO_SYNC) } {\n")
        sdc.write("\tset out_ext_delay 4\n")
        sdc.write("\tputs \"\\[INFO\\]: Setting output ports external delay to: $out_ext_delay\"\n")
        for cons in signoff_out_async:
            sdc.write(f"\t{cons}")
        sdc.write("}\n")
        sdc.write("\n# Output loads\n")
        for cons in output_loads:
            sdc.write(cons)

    print(f"generated sdc: {output_sdc}")
    print(f"signoff sdc: {output_sdc_signoff}")

def predefined_cons(timestr):
    statements = []
    statements.append("# generated by get_frigate_upw_sdc.py\n")
    statements.append(f"# Date: {timestr}\n")
    statements.append("\n### Note:\n")
    statements.append("# - IO ports are assumed to be asynchronous. If they're synchronous to the clock, update the variable IO_SYNC to 1.\n")
    statements.append("#   As well, update in_ext_delay and out_ext_delay with the required I/O external delays.\n")
    statements.append("\n#------------------------------------------#\n")
    statements.append("# Pre-defined Constraints\n")
    statements.append("#------------------------------------------#\n")
    statements.append("set ::env(IO_SYNC) 0\n")
    statements.append("\n# Clock network\n")
    statements.append("if {[info exists ::env(CLOCK_PORT)] && $::env(CLOCK_PORT) != \"\"} {\n")
    statements.append("\tset clk_input $::env(CLOCK_PORT)\n")
    statements.append("\tcreate_clock [get_ports $clk_input] -name clk -period $::env(CLOCK_PERIOD)\n")
    statements.append("\tputs \"\\[INFO\\]: Creating clock {clk} for port $clk_input with period: $::env(CLOCK_PERIOD)\"\n")
    statements.append("} else {\n")
    statements.append("\tset clk_input __VIRTUAL_CLK__\n")
    statements.append("\tcreate_clock -name clk -period $::env(CLOCK_PERIOD)\n")
    statements.append("\tputs \"\\[INFO\\]: Creating virtual clock with period: $::env(CLOCK_PERIOD)\"\n")
    statements.append("}\n")
    statements.append("if { ![info exists ::env(SYNTH_CLK_DRIVING_CELL)] } {\n")
    statements.append("\tset ::env(SYNTH_CLK_DRIVING_CELL) $::env(SYNTH_DRIVING_CELL)\n")
    statements.append("}\n")
    statements.append("if { ![info exists ::env(SYNTH_CLK_DRIVING_CELL_PIN)] } {\n")
    statements.append("\tset ::env(SYNTH_CLK_DRIVING_CELL_PIN) $::env(SYNTH_DRIVING_CELL_PIN)\n")
    statements.append("}\n")
    statements.append("\n# Clock non-idealities\n")
    statements.append("set_propagated_clock [all_clocks]\n")
    statements.append("set_clock_uncertainty $::env(CLOCK_UNCERTAINTY_CONSTRAINT) [get_clocks {clk}]\n")
    statements.append("puts \"\\[INFO\\]: Setting clock uncertainity to: $::env(CLOCK_UNCERTAINTY_CONSTRAINT)\"\n")
    statements.append("set_clock_transition $::env(CLOCK_TRANSITION_CONSTRAINT) [get_clocks {clk}]\n")
    statements.append("puts \"\\[INFO\\]: Setting clock transition to: $::env(CLOCK_TRANSITION_CONSTRAINT)\"\n")
    statements.append("\n# Maximum transition time for the design nets\n")
    statements.append("set_max_transition $::env(MAX_TRANSITION_CONSTRAINT) [current_design]\n")
    statements.append("puts \"\\[INFO\\]: Setting maximum transition to: $::env(MAX_TRANSITION_CONSTRAINT)\"\n")
    statements.append("\n# Maximum fanout\n")
    statements.append("set_max_fanout $::env(MAX_FANOUT_CONSTRAINT) [current_design]\n")
    statements.append("puts \"\\[INFO\\]: Setting maximum fanout to: $::env(MAX_FANOUT_CONSTRAINT)\"\n")
    statements.append("\n# Timing paths delays derate\n")
    statements.append("set_timing_derate -early [expr {1-$::env(TIME_DERATING_CONSTRAINT)/100}]\n")
    statements.append("set_timing_derate -late [expr {1+$::env(TIME_DERATING_CONSTRAINT)/100}]\n")
    statements.append("puts \"\\[INFO\\]: Setting timing derate to: $::env(TIME_DERATING_CONSTRAINT) %\"\n")
    statements.append("\n# Multicycle paths\n")
    statements.append(f"set_multicycle_path {f'-setup 2':9}-through [get_ports {{HADDR*}}] -through [get_ports {{HRDATA*}}]\n")
    statements.append(f"set_multicycle_path {f'-hold 1':9}-through [get_ports {{HADDR*}}] -through [get_ports {{HRDATA*}}]\n")
    statements.append("\n# Constant Ports\n")
    statements.append(f"set_case_analysis 1 [get_ports {{HSEL}}]\n")
    statements.append(f"set_case_analysis 0 [get_ports {{HTRANS[0]}}]\n")
    return statements

def predefined_signoff_cons(timestr):
    statements = []
    statements.append("# generated by get_frigate_upw_sdc.py\n")
    statements.append(f"# Date: {timestr}\n")
    statements.append("\n### Note:\n")
    statements.append("# - IO ports are assumed to be asynchronous. If they're synchronous to the clock, update the variable IO_SYNC to 1.\n")
    statements.append("#   As well, update in_ext_delay and out_ext_delay with the required I/O external delays.\n")
    statements.append("\n#------------------------------------------#\n")
    statements.append("# Pre-defined Constraints\n")
    statements.append("#------------------------------------------#\n")
    statements.append("set ::env(IO_SYNC) 0\n")
    statements.append("\n# Clock network\n")
    statements.append("if {[info exists ::env(CLOCK_PORT)] && $::env(CLOCK_PORT) != \"\"} {\n")
    statements.append("\tset clk_input $::env(CLOCK_PORT)\n")
    statements.append("\tcreate_clock [get_ports $clk_input] -name clk -period 25\n")
    statements.append("\tputs \"\\[INFO\\]: Creating clock {clk} for port $clk_input with period: 25\"\n")
    statements.append("} else {\n")
    statements.append("\tset clk_input __VIRTUAL_CLK__\n")
    statements.append("\tcreate_clock -name clk -period 25\n")
    statements.append("\tputs \"\\[INFO\\]: Creating virtual clock with period: 25\"\n")
    statements.append("}\n")
    statements.append("if { ![info exists ::env(SYNTH_CLK_DRIVING_CELL)] } {\n")
    statements.append("\tset ::env(SYNTH_CLK_DRIVING_CELL) $::env(SYNTH_DRIVING_CELL)\n")
    statements.append("}\n")
    statements.append("if { ![info exists ::env(SYNTH_CLK_DRIVING_CELL_PIN)] } {\n")
    statements.append("\tset ::env(SYNTH_CLK_DRIVING_CELL_PIN) $::env(SYNTH_DRIVING_CELL_PIN)\n")
    statements.append("}\n")
    statements.append("\n# Clock non-idealities\n")
    statements.append("set_propagated_clock [all_clocks]\n")
    statements.append("set_clock_uncertainty 0.1 [get_clocks {clk}]\n")
    statements.append("puts \"\\[INFO\\]: Setting clock uncertainity to: 0.1\"\n")
    statements.append("\n# Maximum fanout\n")
    statements.append("set_max_fanout $::env(MAX_FANOUT_CONSTRAINT) [current_design]\n")
    statements.append("puts \"\\[INFO\\]: Setting maximum fanout to: $::env(MAX_FANOUT_CONSTRAINT)\"\n")
    statements.append("\n# Timing paths delays derate\n")
    statements.append("set_timing_derate -early [expr {1-5.0/100}]\n")
    statements.append("set_timing_derate -late [expr {1+5.0/100}]\n")
    statements.append("puts \"\\[INFO\\]: Setting timing derate to: 5.0 %\"\n")
    statements.append("\n# Multicycle paths\n")
    statements.append(f"set_multicycle_path {f'-setup 2':9}-through [get_ports {{HADDR*}}] -through [get_ports {{HRDATA*}}]\n")
    statements.append(f"set_multicycle_path {f'-hold 1':9}-through [get_ports {{HADDR*}}] -through [get_ports {{HRDATA*}}]\n")
    statements.append("\n# Constant Ports\n")
    statements.append(f"set_case_analysis 1 [get_ports {{HSEL}}]\n")
    statements.append(f"set_case_analysis 0 [get_ports {{HTRANS[0]}}]\n")
    return statements

def find_value(n):
    # timing report table has Cap, transition, increment, and total path delay columns
    # n is -4 for cap, -3 for transition, and -1 for path delay
    return lambda path_line: float(
        re.findall(
            r"[+-]? *(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?", path_line
        )[n].strip()
    )

def get_path_delay(path_line):
    delay = find_value(-1)
    return delay(path_line)

def get_transition(path_line):
    tran = find_value(-3)
    return tran(path_line)

def get_load(path_line):
    load = find_value(-4)
    return load(path_line)

def bus_info(net):
    is_bus = False
    name = ""
    if "[" in net:
        name = net.split("[")[0]
        is_bus = True
    return is_bus, name

def get_input_delays_cons(min_rpt, max_rpt):
    report = Report(min_rpt)
    cons = []
    async_cons = []
    signoff_cons = []
    signoff_async_cons = []
    nets = []
    io_ports = []
    buses = []
    delay = {}
    for path in report.paths:
        clock_value = 0
        delay_value = 0
        in_value = 0
        net = ""
        if path.category == "reg-reg":
            for path_line in path.path.split("\n"):
                if "clock network delay" in path_line:
                    clock_value = get_path_delay(path_line)
                elif "user_project_wrapper" in path_line:
                    net = textwrap.dedent(path_line).split(" ")[0].split("/")[-1]
                    delay_value = get_path_delay(path_line)
                    delta = round(delay_value - clock_value - var, 2)
                    if delta < 0:
                        delta = 0
                    is_bus, bus = bus_info(net)
                    if is_bus:
                        if bus not in buses:
                            buses.append(bus)
                            delay[bus] = delta
                        delay[bus] = min(delay[bus], delta)
                    else:
                        nets.append(net)
                        delay[net] = delta
                    break
        elif path.category == "input-reg":
            for path_line in path.path.split("\n"):
                if "input external delay" in path_line:
                    in_value = get_path_delay(path_line)
                elif "user_project_wrapper" in path_line:
                    port = textwrap.dedent(path_line).split(" ")[0].split("/")[-1].split("[")[0]
                    delay_value = get_path_delay(path_line)
                    delta = round(delay_value - in_value - var, 2)
                    if port not in io_ports:
                        io_ports.append(port)
                        delay[port] = delta
                    delay[port] = min(delay[port], delta)
                    break
    for net in nets:
        cons.append(
            f"set_input_delay -min {f'{delay[net]}':6} -clock [get_clocks {{clk}}] [get_ports {{{net}}}]\n"
        )
        signoff_cons.append(
            f"set_input_delay -min {f'{delay[net] + var:.2f}':6} -clock [get_clocks {{clk}}] [get_ports {{{net}}}]\n"
        )
    for bus in buses:
        cons.append(
            f"set_input_delay -min {f'{delay[bus]}':6} -clock [get_clocks {{clk}}] [get_ports {{{bus}[*]}}]\n"
        )
        signoff_cons.append(
            f"set_input_delay -min {f'{delay[bus] + var:.2f}':6} -clock [get_clocks {{clk}}] [get_ports {{{bus}[*]}}]\n"
        )
    for port in io_ports:
        async_cons.append(
            f"set_input_delay -min [expr $in_ext_delay + {f'{delay[port]}':6}] -clock [get_clocks {{clk}}] [get_ports {{{port}[*]}}]\n"
        )
        signoff_async_cons.append(
            f"set_input_delay -min [expr $in_ext_delay + {f'{delay[port] + var:.2f}':6}] -clock [get_clocks {{clk}}] [get_ports {{{port}[*]}}]\n"
        )

    report = Report(max_rpt)
    nets = []
    io_ports = []
    buses = []
    delay = {}
    for path in report.paths:
        clock_value = 0
        delay_value = 0
        in_value = 0
        net = ""
        if path.category == "reg-reg":
            for path_line in path.path.split("\n"):
                if "clock network delay" in path_line:
                    clock_value = get_path_delay(path_line)
                elif "user_project_wrapper" in path_line:
                    net = textwrap.dedent(path_line).split(" ")[0].split("/")[-1]
                    delay_value = get_path_delay(path_line)
                    delta = round(delay_value - clock_value + var, 2)
                    is_bus, bus = bus_info(net)
                    if is_bus:
                        if bus not in buses:
                            buses.append(bus)
                            delay[bus] = delta
                        delay[bus] = max(delay[bus], delta)
                    else:
                        nets.append(net)
                        delay[net] = delta
                    break
        elif path.category == "input-reg":
            for path_line in path.path.split("\n"):
                if "input external delay" in path_line:
                    in_value = get_path_delay(path_line)
                elif "user_project_wrapper" in path_line:
                    port = textwrap.dedent(path_line).split(" ")[0].split("/")[-1].split("[")[0]
                    delay_value = get_path_delay(path_line)
                    delta = round(delay_value - in_value + var, 2)
                    if port not in io_ports:
                        io_ports.append(port)
                        delay[port] = delta
                    delay[port] = max(delay[port], delta)
                    break
    for net in nets:
        cons.append(
            f"set_input_delay -max {f'{delay[net]}':6} -clock [get_clocks {{clk}}] [get_ports {{{net}}}]\n"
        )
        signoff_cons.append(
            f"set_input_delay -max {f'{delay[net] - var:.2f}':6} -clock [get_clocks {{clk}}] [get_ports {{{net}}}]\n"
        )
    for bus in buses:
        cons.append(
            f"set_input_delay -max {f'{delay[bus]}':6} -clock [get_clocks {{clk}}] [get_ports {{{bus}[*]}}]\n"
        )
        signoff_cons.append(
            f"set_input_delay -max {f'{delay[bus] - var:.2f}':6} -clock [get_clocks {{clk}}] [get_ports {{{bus}[*]}}]\n"
        )
    for port in io_ports:
        async_cons.append(
            f"set_input_delay -max [expr $in_ext_delay + {f'{delay[port]}':6}] -clock [get_clocks {{clk}}] [get_ports {{{port}[*]}}]\n"
        )
        signoff_async_cons.append(
            f"set_input_delay -max [expr $in_ext_delay + {f'{delay[port] - var:.2f}':6}] -clock [get_clocks {{clk}}] [get_ports {{{port}[*]}}]\n"
        )

    cons.sort()
    async_cons.sort()
    signoff_cons.sort()
    signoff_async_cons.sort()
    return cons, async_cons, signoff_cons, signoff_async_cons

def get_output_delays_cons(min_rpt, max_rpt):
    report = Report(min_rpt)
    cons = []
    async_cons = []
    signoff_cons = []
    signoff_async_cons = []
    nets = []
    io_ports = []
    buses = []
    delay = {}
    for path in report.paths:
        mprj_delay = 0
        data_arrival_time = 0
        net = ""
        if path.category == "reg-reg":
            for path_line in path.path.split("\n"):
                if "user_project_wrapper" in path_line:
                    net = textwrap.dedent(path_line).split(" ")[0].split("/")[-1]
                    mprj_delay = get_path_delay(path_line)
                elif "data arrival time" in path_line:
                    data_arrival_time = get_path_delay(path_line)
                    delta = round(data_arrival_time - mprj_delay - var, 2)
                    if delta < 0:
                        delta = 0
                    is_bus, bus = bus_info(net)
                    if is_bus:
                        if bus not in buses:
                            buses.append(bus)
                            delay[bus] = delta
                        delay[bus] = min(delay[bus], delta)
                    else:
                        nets.append(net)
                        delay[net] = delta
                    break
        elif path.category == "reg-output":
            for path_line in path.path.split("\n"):
                if "user_project_wrapper" in path_line:
                    port = textwrap.dedent(path_line).split(" ")[0].split("/")[-1].split("[")[0]
                    mprj_delay = get_path_delay(path_line)
                elif "data arrival time" in path_line:
                    data_arrival_time = get_path_delay(path_line)
                    delta = round(data_arrival_time - mprj_delay - var, 2)
                    if port not in io_ports:
                        io_ports.append(port)
                        delay[port] = delta
                    delay[port] = min(delay[port], delta)
                    break
    for net in nets:
        cons.append(
            f"set_output_delay -min {f'{delay[net]}':6} -clock [get_clocks {{clk}}] [get_ports {{{net}}}]\n"
        )
        signoff_cons.append(
            f"set_output_delay -min {f'{delay[net] + var:.2f}':6} -clock [get_clocks {{clk}}] [get_ports {{{net}}}]\n"
        )
    for bus in buses:
        cons.append(
            f"set_output_delay -min {f'{delay[bus]}':6} -clock [get_clocks {{clk}}] [get_ports {{{bus}[*]}}]\n"
        )
        signoff_cons.append(
            f"set_output_delay -min {f'{delay[bus] + var:.2f}':6} -clock [get_clocks {{clk}}] [get_ports {{{bus}[*]}}]\n"
        )
    for port in io_ports:
        async_cons.append(
            f"set_output_delay -min [expr $out_ext_delay + {f'{delay[port]}':6}] -clock [get_clocks {{clk}}] [get_ports {{{port}[*]}}]\n"
        )
        signoff_async_cons.append(
            f"set_output_delay -min [expr $out_ext_delay + {f'{delay[port] + var:.2f}':6}] -clock [get_clocks {{clk}}] [get_ports {{{port}[*]}}]\n"
        )

    report = Report(max_rpt)
    nets = []
    io_ports = []
    buses = []
    for path in report.paths:
        mprj_delay = 0
        data_arrival_time = 0
        net = ""
        if path.category == "reg-reg":
            for path_line in path.path.split("\n"):
                if "user_project_wrapper" in path_line:
                    net = textwrap.dedent(path_line).split(" ")[0].split("/")[-1]
                    mprj_delay = get_path_delay(path_line)
                elif "data arrival time" in path_line:
                    data_arrival_time = get_path_delay(path_line)
                    delta = round(data_arrival_time - mprj_delay + var, 2)
                    is_bus, bus = bus_info(net)
                    if is_bus:
                        if bus not in buses:
                            buses.append(bus)
                            delay[bus] = delta
                        delay[bus] = max(delay[bus], delta)
                    else:
                        nets.append(net)
                        delay[net] = delta
                    break
        elif path.category == "reg-output":
            for path_line in path.path.split("\n"):
                if "user_project_wrapper" in path_line:
                    port = textwrap.dedent(path_line).split(" ")[0].split("/")[-1].split("[")[0]
                    mprj_delay = get_path_delay(path_line)
                elif "data arrival time" in path_line:
                    data_arrival_time = get_path_delay(path_line)
                    delta = round(data_arrival_time - mprj_delay + var, 2)
                    if port not in io_ports:
                        io_ports.append(port)
                        delay[port] = delta
                    delay[port] = max(delay[port], delta)
                    break
    for net in nets:
        cons.append(
            f"set_output_delay -max {f'{delay[net]}':6} -clock [get_clocks {{clk}}] [get_ports {{{net}}}]\n"
        )
        signoff_cons.append(
            f"set_output_delay -max {f'{delay[net] - var:.2f}':6} -clock [get_clocks {{clk}}] [get_ports {{{net}}}]\n"
        )
    for bus in buses:
        cons.append(
            f"set_output_delay -max {f'{delay[bus]}':6} -clock [get_clocks {{clk}}] [get_ports {{{bus}[*]}}]\n"
        )
        signoff_cons.append(
            f"set_output_delay -max {f'{delay[bus] - var:.2f}':6} -clock [get_clocks {{clk}}] [get_ports {{{bus}[*]}}]\n"
        )
    for port in io_ports:
        async_cons.append(
            f"set_output_delay -max [expr $out_ext_delay + {f'{delay[port]}':6}] -clock [get_clocks {{clk}}] [get_ports {{{port}[*]}}]\n"
        )
        signoff_async_cons.append(
            f"set_output_delay -max [expr $out_ext_delay + {f'{delay[port] - var:.2f}':6}] -clock [get_clocks {{clk}}] [get_ports {{{port}[*]}}]\n"
        )
    cons.sort()
    async_cons.sort()
    signoff_cons.sort()
    signoff_async_cons.sort()
    return cons, async_cons, signoff_cons, signoff_async_cons

def get_input_transitions_cons(min_rpt, max_rpt):
    report = Report(min_rpt)
    cons = []
    nets = []
    buses = []
    tran = {}
    for path in report.paths:
        input_transition = 0
        net = ""
        path_lines = path.path.split("\n")
        for i in range(len(path_lines)):
            path_line = path_lines[i]
            if "user_project_wrapper" in path_line:
                net = textwrap.dedent(path_line).split(" ")[0].split("/")[-1]
                input_transition_line = path_lines[i - 1]
                if "mgmt_protect" in input_transition_line or "gpio_control_block" in input_transition_line:
                    input_transition_line = path_lines[i - 2]
                input_transition = get_transition(input_transition_line)
                input_transition = round(input_transition, 2)
                is_bus, bus = bus_info(net)
                if is_bus:
                    if bus not in buses:
                        buses.append(bus)
                        tran[bus] = input_transition
                    tran[bus] = min(tran[bus], input_transition)
                else:
                    nets.append(net)
                    tran[net] = input_transition
                break
    for net in nets:
        cons.append(
            f"set_input_transition -min {f'{tran[net]}':4} [get_ports {{{net}}}]\n"
        )
    for bus in buses:
        cons.append(
            f"set_input_transition -min {f'{tran[bus]}':4} [get_ports {{{bus}[*]}}]\n"
        )

    report = Report(max_rpt)
    nets = []
    buses = []
    for path in report.paths:
        input_transition = 0
        net = ""
        path_lines = path.path.split("\n")
        for i in range(len(path_lines)):
            path_line = path_lines[i]
            if "user_project_wrapper" in path_line:
                net = textwrap.dedent(path_line).split(" ")[0].split("/")[-1]
                input_transition_line = path_lines[i - 1]
                if "mgmt_protect" in input_transition_line or "gpio_control_block" in input_transition_line:
                    input_transition_line = path_lines[i - 2]
                input_transition = get_transition(input_transition_line)
                input_transition = round(input_transition, 2)
                is_bus, bus = bus_info(net)
                if is_bus:
                    if bus not in buses:
                        buses.append(bus)
                    tran[bus] = max(tran[bus], input_transition)
                else:
                    nets.append(net)
                    tran[net] = input_transition
                break
    for net in nets:
        cons.append(
            f"set_input_transition -max {f'{tran[net]}':4} [get_ports {{{net}}}]\n"
        )
    for bus in buses:
        cons.append(
            f"set_input_transition -max {f'{tran[bus]}':4} [get_ports {{{bus}[*]}}]\n"
        )
    cons.sort()
    return cons

def get_loads_cons(max_rpt):
    report = Report(max_rpt)
    cons = []
    nets = []
    load = {}
    max_load = 0
    for path in report.paths:
        net_load = 0
        net = ""
        path_lines = path.path.split("\n")
        for i in range(len(path_lines)):
            path_line = path_lines[i]
            if "user_project_wrapper" in path_line:
                net = textwrap.dedent(path_line).split(" ")[0].split("/")[-1]
                nets.append(net)
                load_line = path_lines[i - 1]
                if "mgmt_protect" in load_line or "gpio_control_block" in load_line:
                    load_line = path_lines[i - 2]
                net_load = get_load(load_line)
                net_load = round(net_load, 2)
                load[net] = net_load
                max_load = max(net_load, max_load)
                break
    sum_load = 0
    for net in nets:
        sum_load += load[net]
    avg_load = sum_load/len(nets)
    print(f"avg {avg_load}")
    cons.append(f"set avg_load {avg_load:.2f}\n")
    cons.append(f"set max_load {max_load}\n")
    cons.append(f"set_load $max_load [all_outputs]\n")
    return cons

def get_clock_cons(min_rpt, max_rpt):
    report_min = Report(min_rpt)
    report_max = Report(max_rpt)
    cons = []

    # first path is the worst HCLK related path
    # min clk insertion delay to core reg is min data report or min clk path in max data report
    # max clk insertion delay to mprj is max data report or max clk path in min data report
    min_path = report_min.paths[0]
    max_path = report_max.paths[0]
    clk_launch = min_path.start_point + "/CLK"
    clk_capture = max_path.end_point + "/CLK"
    clk_tran = 0
    clock_value = 0
    path_lines = max_path.path.split("\n")
    for i in range(len(path_lines)):
        path_line = path_lines[i]
        if "clock (in)" in path_line:
            clock_value = get_path_delay(path_line)
        elif "HCLK (user_project_wrapper)" in path_line:
            max_latency_max_rpt = get_path_delay(path_line)
            max_latency_max_rpt = max_latency_max_rpt - clock_value
            transition_line = path_lines[i - 2]
            clk_tran = get_transition(transition_line)
            clk_tran = round(clk_tran, 2)
        elif clk_capture in path_line:
            min_latency_max_rpt = get_path_delay(path_line)
            min_latency_max_rpt = min_latency_max_rpt - clock_value
            break

    for path_line in min_path.path.split("\n"):
        if "clock (in)" in path_line:
            clock_value = get_path_delay(path_line)
        elif clk_launch in path_line:
            min_latency_min_rpt = get_path_delay(path_line)
            min_latency_min_rpt = min_latency_min_rpt - clock_value
        elif "HCLK (user_project_wrapper)" in path_line:
            max_latency_min_rpt = get_path_delay(path_line)
            max_latency_min_rpt = max_latency_min_rpt - clock_value
            break
    min_latency_min_rpt = 2.2214 
    min_latency_max_rpt = 2.2214
    max_latency_min_rpt = 5.0530
    max_latency_max_rpt = 4.8548
    clk_max_latency = round(max(max_latency_min_rpt, max_latency_max_rpt), 2)
    clk_min_latency = round(min(min_latency_min_rpt, min_latency_max_rpt), 2)

    cons.append("\n# Clock source latency\n")
    cons.append(f"set clk_max_latency {clk_max_latency}\n")
    cons.append(f"set clk_min_latency {clk_min_latency}\n")
    cons.append("set_clock_latency -source -max $clk_max_latency [get_clocks {clk}]\n")
    cons.append("set_clock_latency -source -min $clk_min_latency [get_clocks {clk}]\n")
    cons.append("puts \"\\[INFO\\]: Setting clock latency range: $clk_min_latency : $clk_max_latency\"\n")
    cons.append("\n# Clock input Transition\n")
    cons.append(f"set clk_tran {clk_tran}\n")
    cons.append("set_input_transition $clk_tran [get_ports $clk_input]\n")
    cons.append("puts \"\\[INFO\\]: Setting clock transition: $clk_tran\"\n")

    return cons


if __name__ == "__main__":
    main()
