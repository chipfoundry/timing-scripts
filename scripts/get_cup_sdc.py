from report import Report
import click
import re
import textwrap
import time


@click.command()
@click.option(
    "--mprj-reports-dir",
    required=True,
    type=click.Path(exists=True, file_okay=False),
    help="path to the directory that includes the mprj timing reports from PrimeTime",
)
@click.option(
    "-o",
    "--output-sdc",
    required=True,
    type=str,
    help="output sdc",
)
def main(mprj_reports_dir, output_sdc):
    # a variation value of +-0.4 is applied on the extracted constraints
    # the value is determined after extracting constraints from
    # multiple implementations of caravel
    global var
    var = 0.4
    timestr = time.strftime("%Y/%m/%d")

    in_min_rpt = f"{mprj_reports_dir}/in-min.rpt"
    in_max_rpt = f"{mprj_reports_dir}/in-max.rpt"
    out_min_rpt = f"{mprj_reports_dir}/out-min.rpt"
    out_max_rpt = f"{mprj_reports_dir}/out-max.rpt"
    clk_min_rpt = f"{mprj_reports_dir}/clk-min.rpt"
    clk_max_rpt = f"{mprj_reports_dir}/clk-max.rpt"

    input_delays, in_async_cons = get_input_delays_cons(in_min_rpt, in_max_rpt)
    input_trans = get_input_transitions_cons(in_min_rpt, in_max_rpt)
    output_delays, out_async_cons = get_output_delays_cons(out_min_rpt, out_max_rpt)
    output_loads = get_loads_cons(out_max_rpt)
    clk_cons = get_clock_cons(clk_min_rpt, clk_max_rpt)
    predefined = predefined_cons(timestr)
    with open(output_sdc, "w") as sdc:
        for cons in predefined:
            sdc.write(cons)
        sdc.write("\n#------------------------------------------#\n")
        sdc.write("# Retrieved Constraints\n")
        sdc.write("#------------------------------------------#\n")
        for cons in clk_cons:
            sdc.write(cons)
        sdc.write("\n# Input delays\n")
        for cons in input_delays:
            sdc.write(cons)
        sdc.write("if { $::env(IO_SYNC) } {\n")
        sdc.write("\tset in_ext_delay 4\n")
        sdc.write("\tputs \"\\[INFO\\]: Setting input ports external delay to: $in_ext_delay\"\n")
        for cons in in_async_cons:
            sdc.write(f"\t{cons}")
        sdc.write("}\n")
        sdc.write("\n# Input Transition\n")
        for cons in input_trans:
            sdc.write(cons)
        sdc.write("\n# Output delays\n")
        for cons in output_delays:
            sdc.write(cons)
        sdc.write("if { $::env(IO_SYNC) } {\n")
        sdc.write("\tset out_ext_delay 4\n")
        sdc.write("\tputs \"\\[INFO\\]: Setting output ports external delay to: $out_ext_delay\"\n")
        for cons in out_async_cons:
            sdc.write(f"\t{cons}")
        sdc.write("}\n")
        sdc.write("\n# Output loads\n")
        for cons in output_loads:
            sdc.write(cons)

    print(f"generated sdc: {output_sdc}")

def predefined_cons(timestr):
    statements = []
    statements.append("# generated by get_cup_sdc.py\n")
    statements.append(f"# Date: {timestr}\n")
    statements.append("\n### Note:\n")
    statements.append("# - input clock transition and latency are set for wb_clk_i port.\n")
    statements.append("#   If your design is using the user_clock2, update the clock constraints to reflect that and use usr_* variables.\n")
    statements.append("# - IO ports are assumed to be asynchronous. If they're synchronous to the clock, update the variable IO_SYNC to 1.\n")
    statements.append("#   As well, update in_ext_delay and out_ext_delay with the required I/O external delays.\n")
    statements.append("\n#------------------------------------------#\n")
    statements.append("# Pre-defined Constraints\n")
    statements.append("#------------------------------------------#\n")
    statements.append("\n# Clock network\n")
    statements.append("if {[info exists ::env(CLOCK_PORT)] && $::env(CLOCK_PORT) != \"\"} {\n")
    statements.append("\tset clk_input $::env(CLOCK_PORT)\n")
    statements.append("\tcreate_clock [get_ports $clk_input] -name clk -period $::env(CLOCK_PERIOD)\n")
    statements.append("\tputs \"\\[INFO\\]: Creating clock {clk} for port $clk_input with period: $::env(CLOCK_PERIOD)\"\n")
    statements.append("} else {\n")
    statements.append("\tset clk_input __VIRTUAL_CLK__\n")
    statements.append("\tcreate_clock -name clk -period $::env(CLOCK_PERIOD)\n")
    statements.append("\tputs \"\\[INFO\\]: Creating virtual clock with period: $::env(CLOCK_PERIOD)\"\n")
    statements.append("}\n")
    statements.append("if { ![info exists ::env(SYNTH_CLK_DRIVING_CELL)] } {\n")
    statements.append("\tset ::env(SYNTH_CLK_DRIVING_CELL) $::env(SYNTH_DRIVING_CELL)\n")
    statements.append("}\n")
    statements.append("if { ![info exists ::env(SYNTH_CLK_DRIVING_CELL_PIN)] } {\n")
    statements.append("\tset ::env(SYNTH_CLK_DRIVING_CELL_PIN) $::env(SYNTH_DRIVING_CELL_PIN)\n")
    statements.append("}\n")
    statements.append("\n# Clock non-idealities\n")
    statements.append("set_propagated_clock [all_clocks]\n")
    statements.append("set_clock_uncertainty $::env(SYNTH_CLOCK_UNCERTAINTY) [get_clocks {clk}]\n")
    statements.append("puts \"\\[INFO\\]: Setting clock uncertainity to: $::env(SYNTH_CLOCK_UNCERTAINTY)\"\n")
    statements.append("set_clock_transition $::env(SYNTH_CLOCK_TRANSITION) [get_clocks {clk}]\n")
    statements.append("puts \"\\[INFO\\]: Setting clock transition to: $::env(SYNTH_CLOCK_TRANSITION)\"\n")
    statements.append("\n# Maximum transition time for the design nets\n")
    statements.append("set_max_transition $::env(SYNTH_MAX_TRAN) [current_design]\n")
    statements.append("puts \"\\[INFO\\]: Setting maximum transition to: $::env(SYNTH_MAX_TRAN)\"\n")
    statements.append("\n# Maximum fanout\n")
    statements.append("set_max_fanout $::env(SYNTH_MAX_FANOUT) [current_design]\n")
    statements.append("puts \"\\[INFO\\]: Setting maximum fanout to: $::env(SYNTH_MAX_FANOUT)\"\n")
    statements.append("\n# Timing paths delays derate\n")
    statements.append("set_timing_derate -early [expr {1-$::env(SYNTH_TIMING_DERATE)}]\n")
    statements.append("set_timing_derate -late [expr {1+$::env(SYNTH_TIMING_DERATE)}]\n")
    statements.append("puts \"\\[INFO\\]: Setting timing derate to: [expr {$::env(SYNTH_TIMING_DERATE) * 100}] %\"\n")
    statements.append("\n# Reset input delay\n")
    statements.append("set_input_delay [expr $::env(CLOCK_PERIOD) * 0.5] -clock [get_clocks {clk}] [get_ports {wb_rst_i}]\n")
    statements.append("\n# Multicycle paths\n")
    statements.append(f"set_multicycle_path {f'-setup 2':9}-through [get_ports {{wbs_ack_o}}]\n")
    statements.append(f"set_multicycle_path {f'-hold 1':9}-through [get_ports {{wbs_ack_o}}]\n")
    statements.append(f"set_multicycle_path {f'-setup 2':9}-through [get_ports {{wbs_cyc_i}}]\n")
    statements.append(f"set_multicycle_path {f'-hold 1':9}-through [get_ports {{wbs_cyc_i}}]\n")
    statements.append(f"set_multicycle_path {f'-setup 2':9}-through [get_ports {{wbs_stb_i}}]\n")
    statements.append(f"set_multicycle_path {f'-hold 1':9}-through [get_ports {{wbs_stb_i}}]\n")

    return statements

def find_value(n):
    # timing report table has Cap, transition, increment, and total path delay columns
    # n is -4 for cap, -3 for transition, and -1 for path delay
    return lambda path_line: float(
        re.findall(
            r"[+-]? *(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?", path_line
        )[n].strip()
    )

def get_path_delay(path_line):
    delay = find_value(-1)
    return delay(path_line)

def get_transition(path_line):
    tran = find_value(-3)
    return tran(path_line)

def get_load(path_line):
    load = find_value(-4)
    return load(path_line)

def bus_info(net):
    is_bus = False
    name = ""
    if "[" in net:
        name = net.split("[")[0]
        is_bus = True
    return is_bus, name

def get_input_delays_cons(min_rpt, max_rpt):
    report = Report(min_rpt)
    cons = []
    async_cons = []
    nets = []
    io_ports = []
    buses = []
    delay = {}
    for path in report.paths:
        clock_value = 0
        delay_value = 0
        in_value = 0
        net = ""
        if path.category == "reg-reg":
            for path_line in path.path.split("\n"):
                if "clock network delay" in path_line:
                    clock_value = get_path_delay(path_line)
                elif "user_project_wrapper" in path_line:
                    net = textwrap.dedent(path_line).split(" ")[0].split("/")[-1]
                    delay_value = get_path_delay(path_line)
                    delta = round(delay_value - clock_value - var, 2)
                    if delta < 0:
                        delta = 0
                    is_bus, bus = bus_info(net)
                    if is_bus:
                        if bus not in buses:
                            buses.append(bus)
                            delay[bus] = delta
                        delay[bus] = min(delay[bus], delta)
                    else:
                        nets.append(net)
                        delay[net] = delta
                    break
        elif path.category == "input-reg":
            for path_line in path.path.split("\n"):
                if "input external delay" in path_line:
                    in_value = get_path_delay(path_line)
                elif "user_project_wrapper" in path_line:
                    port = textwrap.dedent(path_line).split(" ")[0].split("/")[-1].split("[")[0]
                    delay_value = get_path_delay(path_line)
                    delta = round(delay_value - in_value - var, 2)
                    if port not in io_ports:
                        io_ports.append(port)
                        delay[port] = delta
                    delay[port] = min(delay[port], delta)
                    break
    for net in nets:
        cons.append(
            f"set_input_delay {f'-min {delay[net]}':10}-clock [get_clocks {{clk}}] [get_ports {{{net}}}]\n"
        )
    for bus in buses:
        cons.append(
            f"set_input_delay {f'-min {delay[bus]}':10}-clock [get_clocks {{clk}}] [get_ports {{{bus}[*]}}]\n"
        )
    for port in io_ports:
        async_cons.append(
            f"set_input_delay {f'-min [expr $in_ext_delay + {delay[port]}]':33}-clock [get_clocks {{clk}}] [get_ports {{{port}[*]}}]\n"
        )

    report = Report(max_rpt)
    nets = []
    io_ports = []
    buses = []
    delay = {}
    for path in report.paths:
        clock_value = 0
        delay_value = 0
        in_value = 0
        net = ""
        if path.category == "reg-reg":
            for path_line in path.path.split("\n"):
                if "clock network delay" in path_line:
                    clock_value = get_path_delay(path_line)
                elif "user_project_wrapper" in path_line:
                    net = textwrap.dedent(path_line).split(" ")[0].split("/")[-1]
                    delay_value = get_path_delay(path_line)
                    delta = round(delay_value - clock_value + var, 2)
                    is_bus, bus = bus_info(net)
                    if is_bus:
                        if bus not in buses:
                            buses.append(bus)
                            delay[bus] = delta
                        delay[bus] = max(delay[bus], delta)
                    else:
                        nets.append(net)
                        delay[net] = delta
                    break
        elif path.category == "input-reg":
            for path_line in path.path.split("\n"):
                if "input external delay" in path_line:
                    in_value = get_path_delay(path_line)
                elif "user_project_wrapper" in path_line:
                    port = textwrap.dedent(path_line).split(" ")[0].split("/")[-1].split("[")[0]
                    delay_value = get_path_delay(path_line)
                    delta = round(delay_value - in_value + var, 2)
                    if port not in io_ports:
                        io_ports.append(port)
                        delay[port] = delta
                    delay[port] = max(delay[port], delta)
                    break
    for net in nets:
        cons.append(
            f"set_input_delay {f'-max {delay[net]}':10}-clock [get_clocks {{clk}}] [get_ports {{{net}}}]\n"
        )
    for bus in buses:
        cons.append(
            f"set_input_delay {f'-max {delay[bus]}':10}-clock [get_clocks {{clk}}] [get_ports {{{bus}[*]}}]\n"
        )
    for port in io_ports:
        async_cons.append(
            f"set_input_delay {f'-max [expr $in_ext_delay + {delay[port]}]':33}-clock [get_clocks {{clk}}] [get_ports {{{port}[*]}}]\n"
        )

    cons.sort()
    async_cons.sort()
    return cons, async_cons

def get_output_delays_cons(min_rpt, max_rpt):
    report = Report(min_rpt)
    cons = []
    async_cons = []
    nets = []
    io_ports = []
    buses = []
    delay = {}
    for path in report.paths:
        mprj_delay = 0
        data_arrival_time = 0
        net = ""
        if path.category == "reg-reg":
            for path_line in path.path.split("\n"):
                if "user_project_wrapper" in path_line:
                    net = textwrap.dedent(path_line).split(" ")[0].split("/")[-1]
                    mprj_delay = get_path_delay(path_line)
                elif "data arrival time" in path_line:
                    data_arrival_time = get_path_delay(path_line)
                    delta = round(data_arrival_time - mprj_delay - var, 2)
                    if delta < 0:
                        delta = 0
                    is_bus, bus = bus_info(net)
                    if is_bus:
                        if bus not in buses:
                            buses.append(bus)
                            delay[bus] = delta
                        delay[bus] = min(delay[bus], delta)
                    else:
                        nets.append(net)
                        delay[net] = delta
                    break
        elif path.category == "reg-output":
            for path_line in path.path.split("\n"):
                if "user_project_wrapper" in path_line:
                    port = textwrap.dedent(path_line).split(" ")[0].split("/")[-1].split("[")[0]
                    mprj_delay = get_path_delay(path_line)
                elif "data arrival time" in path_line:
                    data_arrival_time = get_path_delay(path_line)
                    delta = round(data_arrival_time - mprj_delay - var, 2)
                    if port not in io_ports:
                        io_ports.append(port)
                        delay[port] = delta
                    delay[port] = min(delay[port], delta)
                    break
    for net in nets:
        cons.append(
            f"set_output_delay {f'-min {delay[net]}':10}-clock [get_clocks {{clk}}] [get_ports {{{net}}}]\n"
        )
    for bus in buses:
        cons.append(
            f"set_output_delay {f'-min {delay[bus]}':10}-clock [get_clocks {{clk}}] [get_ports {{{bus}[*]}}]\n"
        )
    for port in io_ports:
        async_cons.append(
            f"set_output_delay {f'-min [expr $out_ext_delay + {delay[port]}]':34}-clock [get_clocks {{clk}}] [get_ports {{{port}[*]}}]\n"
        )

    report = Report(max_rpt)
    nets = []
    io_ports = []
    buses = []
    for path in report.paths:
        mprj_delay = 0
        data_arrival_time = 0
        net = ""
        if path.category == "reg-reg":
            for path_line in path.path.split("\n"):
                if "user_project_wrapper" in path_line:
                    net = textwrap.dedent(path_line).split(" ")[0].split("/")[-1]
                    mprj_delay = get_path_delay(path_line)
                elif "data arrival time" in path_line:
                    data_arrival_time = get_path_delay(path_line)
                    delta = round(data_arrival_time - mprj_delay + var, 2)
                    is_bus, bus = bus_info(net)
                    if is_bus:
                        if bus not in buses:
                            buses.append(bus)
                            delay[bus] = delta
                        delay[bus] = max(delay[bus], delta)
                    else:
                        nets.append(net)
                        delay[net] = delta
                    break
        elif path.category == "reg-output":
            for path_line in path.path.split("\n"):
                if "user_project_wrapper" in path_line:
                    port = textwrap.dedent(path_line).split(" ")[0].split("/")[-1].split("[")[0]
                    mprj_delay = get_path_delay(path_line)
                elif "data arrival time" in path_line:
                    data_arrival_time = get_path_delay(path_line)
                    delta = round(data_arrival_time - mprj_delay + var, 2)
                    if port not in io_ports:
                        io_ports.append(port)
                        delay[port] = delta
                    delay[port] = max(delay[port], delta)
                    break
    for net in nets:
        cons.append(
            f"set_output_delay {f'-max {delay[net]}':10}-clock [get_clocks {{clk}}] [get_ports {{{net}}}]\n"
        )
    for bus in buses:
        cons.append(
            f"set_output_delay {f'-max {delay[bus]}':10}-clock [get_clocks {{clk}}] [get_ports {{{bus}[*]}}]\n"
        )
    for port in io_ports:
        async_cons.append(
            f"set_output_delay {f'-max [expr $out_ext_delay + {delay[port]}]':34}-clock [get_clocks {{clk}}] [get_ports {{{port}[*]}}]\n"
        )
    cons.sort()
    async_cons.sort()
    return cons, async_cons

def get_input_transitions_cons(min_rpt, max_rpt):
    report = Report(min_rpt)
    cons = []
    nets = []
    buses = []
    tran = {}
    for path in report.paths:
        input_transition = 0
        net = ""
        path_lines = path.path.split("\n")
        for i in range(len(path_lines)):
            path_line = path_lines[i]
            if "user_project_wrapper" in path_line:
                net = textwrap.dedent(path_line).split(" ")[0].split("/")[-1]
                input_transition_line = path_lines[i - 1]
                input_transition = get_transition(input_transition_line)
                input_transition = round(input_transition, 2)
                is_bus, bus = bus_info(net)
                if is_bus:
                    if bus not in buses:
                        buses.append(bus)
                        tran[bus] = input_transition
                    tran[bus] = min(tran[bus], input_transition)
                else:
                    nets.append(net)
                    tran[net] = input_transition
                break
    for net in nets:
        cons.append(
            f"set_input_transition {f'-min {tran[net]}':10} [get_ports {{{net}}}]\n"
        )
    for bus in buses:
        cons.append(
            f"set_input_transition {f'-min {tran[bus]}':10} [get_ports {{{bus}[*]}}]\n"
        )

    report = Report(max_rpt)
    nets = []
    buses = []
    for path in report.paths:
        input_transition = 0
        net = ""
        path_lines = path.path.split("\n")
        for i in range(len(path_lines)):
            path_line = path_lines[i]
            if "user_project_wrapper" in path_line:
                net = textwrap.dedent(path_line).split(" ")[0].split("/")[-1]
                input_transition_line = path_lines[i - 1]
                input_transition = get_transition(input_transition_line)
                input_transition = round(input_transition, 2)
                is_bus, bus = bus_info(net)
                if is_bus:
                    if bus not in buses:
                        buses.append(bus)
                    tran[bus] = max(tran[bus], input_transition)
                else:
                    nets.append(net)
                    tran[net] = input_transition
                break
    for net in nets:
        cons.append(
            f"set_input_transition {f'-max {tran[net]}':10} [get_ports {{{net}}}]\n"
        )
    for bus in buses:
        cons.append(
            f"set_input_transition {f'-max {tran[bus]}':10} [get_ports {{{bus}[*]}}]\n"
        )
    cons.sort()
    return cons

def get_loads_cons(max_rpt):
    report = Report(max_rpt)
    cons = []
    nets = []
    load = {}
    max_load = 0
    for path in report.paths:
        net_load = 0
        net = ""
        path_lines = path.path.split("\n")
        for i in range(len(path_lines)):
            path_line = path_lines[i]
            if "user_project_wrapper" in path_line:
                net = textwrap.dedent(path_line).split(" ")[0].split("/")[-1]
                nets.append(net)
                load_line = path_lines[i - 1]
                net_load = get_load(load_line)
                net_load = round(net_load, 2)
                load[net] = net_load
                max_load = max(net_load, max_load)
                break
    sum_load = 0
    for net in nets:
        sum_load += load[net]
    print(f"avg {sum_load/len(nets)}")
    cons.append(f"set_load {max_load} [all_outputs]\n")
    return cons

def get_clock_cons(min_rpt, max_rpt):
    report_min = Report(min_rpt)
    report_max = Report(max_rpt)
    cons = []

    # first path is the worst wb_clk_i related path
    # min clk insertion delay to core reg is min data report or min clk path in max data report
    # max clk insertion delay to mprj is max data report or max clk path in min data report
    min_path = report_min.paths[0]
    max_path = report_max.paths[0]
    clk_launch = min_path.start_point + "/CLK"
    clk_capture = max_path.end_point + "/CLK"
    clk_tran = 0
    clock_value = 0
    path_lines = max_path.path.split("\n")
    for i in range(len(path_lines)):
        path_line = path_lines[i]
        if "clock (in)" in path_line:
            clock_value = get_path_delay(path_line)
        elif "wb_clk_i (user_project_wrapper)" in path_line:
            max_latency_max_rpt = get_path_delay(path_line)
            max_latency_max_rpt = max_latency_max_rpt - clock_value
            transition_line = path_lines[i - 1]
            clk_tran = get_transition(transition_line)
            clk_tran = round(clk_tran, 2)
        elif clk_capture in path_line:
            min_latency_max_rpt = get_path_delay(path_line)
            min_latency_max_rpt = min_latency_max_rpt - clock_value
            break

    for path_line in min_path.path.split("\n"):
        if "clock (in)" in path_line:
            clock_value = get_path_delay(path_line)
        elif clk_launch in path_line:
            min_latency_min_rpt = get_path_delay(path_line)
            min_latency_min_rpt = min_latency_min_rpt - clock_value
        elif "wb_clk_i (user_project_wrapper)" in path_line:
            max_latency_min_rpt = get_path_delay(path_line)
            max_latency_min_rpt = max_latency_min_rpt - clock_value
            break

    clk_max_latency = round(max(max_latency_min_rpt, max_latency_max_rpt), 2)
    clk_min_latency = round(min(min_latency_min_rpt, min_latency_max_rpt), 2)

    # second path is the worst user_clock2 related path
    # min user clk insertion delay to mprj is max data report (min clk path)
    # max user clk insertion delay to mprj is min data report (max clk path)
    max_path = report_min.paths[1]
    min_path = report_max.paths[1]
    usr_clk_max_latency = 0
    usr_clk_min_latency = 0
    usr_clk_tran = 0
    path_lines = max_path.path.split("\n")
    for i in range(len(path_lines)):
        path_line = path_lines[i]
        if "clock (in)" in path_line:
            clock_value = get_path_delay(path_line)
        elif "user_clock2 (user_project_wrapper)" in path_line:
            usr_clk_max_latency = get_path_delay(path_line)
            usr_clk_max_latency = round(usr_clk_max_latency - clock_value, 2)
            transition_line = path_lines[i - 1]
            usr_clk_tran = get_transition(transition_line)
            usr_clk_tran = round(usr_clk_tran, 2)

    for path_line in min_path.path.split("\n"):
        if "clock (in)" in path_line:
            clock_value = get_path_delay(path_line)
        elif "user_clock2 (user_project_wrapper)" in path_line:
            usr_clk_min_latency = get_path_delay(path_line)
            usr_clk_min_latency = round(usr_clk_min_latency - clock_value, 2)

    cons.append("\n# Clock source latency\n")
    cons.append(f"set usr_clk_max_latency {usr_clk_max_latency}\n")
    cons.append(f"set usr_clk_min_latency {usr_clk_min_latency}\n")
    cons.append(f"set clk_max_latency {clk_max_latency}\n")
    cons.append(f"set clk_min_latency {clk_min_latency}\n")
    cons.append("set_clock_latency -source -max $clk_max_latency [get_clocks {clk}]\n")
    cons.append("set_clock_latency -source -min $clk_min_latency [get_clocks {clk}]\n")
    cons.append("puts \"\\[INFO\\]: Setting clock latency range: $clk_min_latency : $clk_max_latency\"\n")
    cons.append("\n# Clock input Transition\n")
    cons.append(f"set usr_clk_tran {usr_clk_tran}\n")
    cons.append(f"set clk_tran {clk_tran}\n")
    cons.append("set_input_transition $clk_tran [get_ports $clk_input]\n")
    cons.append("puts \"\\[INFO\\]: Setting clock transition: $clk_tran\"\n")

    return cons


if __name__ == "__main__":
    main()
